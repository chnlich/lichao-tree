\documentclass{article}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{amsmath}

\title{Performance Comparison: Li-Chao Tree vs. Dynamic Convex Hull Trick}
\author{chnlich}
\date{\today}

\begin{document}

\maketitle

\section{Introduction}
This report presents a comparative analysis of two prominent data structures used for maintaining the lower/upper convex hull of a set of lines and performing extremum queries:
\begin{enumerate}
    \item \textbf{Li-Chao Tree}: A segment tree-based approach where each node stores a line that dominates the center of the interval. It supports line insertions and point queries in $\mathcal{O}(\log C)$, where $C$ is the coordinate range.
    \item \textbf{Dynamic Convex Hull Trick (CHT)}: A balanced binary search tree approach (commonly implemented using \texttt{std::set} in C++) that maintains the hull envelope directly by sorting lines by slope. It typically supports insertions and queries in amortized $\mathcal{O}(\log N)$.
\end{enumerate}

\section{Implementation Details}
\subsection{Li-Chao Tree (Dynamic)}
We implemented a sparse, pointer-based Li-Chao Tree supporting a coordinate range of $[-10^9, 10^9]$. Nodes are allocated dynamically on the heap as needed.

\subsection{Li-Chao Tree (Static Allocation)}
To mitigate the overhead of dynamic memory allocation, we implemented a version utilizing a pre-allocated static memory pool (array-based). This approach aims to improve cache locality and reduce the runtime cost associated with the \texttt{new} operator.

\subsection{Dynamic CHT}
We utilized the widely used "LineContainer" implementation (often attributed to the KACTL library), which stores lines in a \texttt{std::set} sorted by slope and maintains intersection points to ensure the hull's validity.

\section{Experimental Setup}
The benchmarks were conducted using the following input distributions:
\begin{itemize}
    \item \textbf{Random}: Lines ($k, m$) and query coordinates ($x$) are generated uniformly at random.
    \item \textbf{Monotonic K}: Lines are inserted in strictly increasing order of slope $k$.
    \item \textbf{Monotonic X}: Queries are performed in strictly increasing order of coordinate $x$.
\end{itemize}
We tested input sizes $N \in \{10^4, 10^5, 2 \cdot 10^5\}$.

\section{Results}
The benchmark results (detailed in \texttt{results.md}) indicate that the Dynamic CHT implementation generally outperforms the Li-Chao Tree variants for the tested input sizes. 

\begin{itemize}
    \item \textbf{Dynamic vs. Static Li-Chao}: Surprisingly, the static memory pool optimization did not yield a significant performance improvement over the dynamic pointer-based version in this test environment. In some cases, it performed slightly slower, possibly due to array bounds checking or different memory access patterns.
    \item \textbf{Overall Performance}: The Dynamic CHT consistently maintained lower execution times. For $N=200,000$ with random inputs, CHT ran in approximately 10ms, while Li-Chao variants required 15-17ms.
\end{itemize}

Despite the raw speed difference, the Li-Chao Tree remains a valuable structure due to its simplicity and robustness against numerical instability, as it does not require calculating intersection points.

\section{Conclusion}
While the Li-Chao Tree offers a theoretically elegant solution with a fixed coordinate universe, the standard library-based Dynamic CHT proves to be highly efficient for competitive programming constraints ($N \le 2 \cdot 10^5$). Future work could explore optimizing the memory layout further or testing on significantly larger datasets where cache locality might play a larger role.

\end{document}
