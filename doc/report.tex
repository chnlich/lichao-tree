\documentclass[11pt,a4paper]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{natbib}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}

\title{\textbf{The Li-Chao Tree: An Alternative Approach to Dynamic Line Envelope Maintenance}}
\author{Li Chao}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
The Li-Chao Tree (LICT), introduced in 2012, provides an alternative approach to the online line envelope maintenance problem. While the Dynamic Convex Hull Trick (CHT) has traditionally been the standard solution, the LICT offers distinct advantages in implementation simplicity, numerical stability, and extensibility to advanced variants such as persistence and line segments. This paper presents a comprehensive analysis of both data structures, including streamlined implementations and empirical performance evaluation. Our results indicate that the Dynamic CHT achieves approximately 1.5 to 2.0 times faster execution in standard benchmarks, while the LICT provides superior ease of implementation and greater flexibility for extensions. We offer practical guidance for selecting the appropriate data structure based on application requirements.
\end{abstract}

\section{Introduction}

Dynamic line envelope maintenance is a fundamental problem in computational geometry with extensive applications in dynamic programming optimization, operations research, and computer graphics. The problem is defined as follows: given a dynamic set of linear functions $y = kx + m$, support efficient insertion of new lines and querying the minimum (or maximum) value at arbitrary $x$ coordinates.

Formally, we require a data structure supporting two operations:
\begin{enumerate}
    \item \textbf{Add Line:} Insert a new line $y = kx + m$ into the structure.
    \item \textbf{Query:} Given $x_0$, compute $\min_{i} \{k_i x_0 + m_i\}$ over all lines currently in the structure.
\end{enumerate}

Both operations must execute in logarithmic time to achieve acceptable performance for large-scale applications.

\subsection{Background and Motivation}

The classical solution to this problem is the Convex Hull Trick (CHT), which maintains the lower envelope of lines explicitly. The Dynamic CHT variant uses a balanced binary search tree to support arbitrary insertion orders in $O(\log n)$ amortized time per operation. While asymptotically optimal, this approach requires complex intersection point calculations and careful handling of numerical precision.

In 2012, we introduced the Li-Chao Tree as an alternative solution that avoids explicit hull maintenance entirely. The LICT employs a divide and conquer strategy over the query coordinate range, achieving $O(\log C)$ time per operation, where $C$ denotes the coordinate range. This approach eliminates the need for intersection calculations, resulting in a simpler implementation with enhanced numerical stability.

\subsection{Contributions}

This paper makes the following contributions:
\begin{enumerate}
    \item We present clean, production ready implementations of both the Standard LICT and Dynamic CHT, suitable for educational and practical use.
    \item We conduct systematic performance evaluation comparing both approaches across multiple problem scales and data distributions.
    \item We analyze the theoretical and practical trade offs between the two data structures, with particular attention to extensibility features including persistence, line segment support, and higher dimensional generalizations.
    \item We provide evidence based guidelines for selecting the appropriate data structure for specific application contexts.
\end{enumerate}

\section{Related Work}\label{sec:related}

\subsection{Convex Hull Trick}

The Convex Hull Trick encompasses two primary variants with different applicability constraints.

\textbf{1. Monotonic CHT:} When lines are inserted in order of monotonic slope, the lower hull can be maintained in a deque, achieving $O(1)$ amortized time per operation for both insertions and queries. This variant is highly efficient when applicable but fails for arbitrary insertion orders.

\textbf{2. Dynamic CHT:} For arbitrary insertion sequences, a balanced binary search tree maintains the hull explicitly. Each insertion and query requires $O(\log n)$ amortized time. The implementation complexity stems from the need to compute and maintain intersection points between adjacent lines in the hull.

The Dynamic CHT requires computing intersection points as $x_{\text{intersect}} = \frac{m_2 - m_1}{k_1 - k_2}$, necessitating careful handling of division by zero (parallel lines), integer overflow, and sign conventions for floored division.

\subsection{The Li-Chao Tree}

The LICT offers a fundamentally different approach based on implicit envelope maintenance through interval subdivision. Rather than tracking the convex hull geometry explicitly, the structure maintains the optimal line at each interval midpoint, recursively partitioning the query range.

\begin{itemize}
    \item \textbf{Time Complexity:} $O(\log C)$ per operation, where $C$ represents the coordinate range (typically $C \approx 10^9$ for 32 bit integers).
    \item \textbf{Space Complexity:} $O(N \log C)$ for $N$ inserted lines, with dynamic node creation ensuring only visited nodes are allocated.
    \item \textbf{Key Characteristics:} No intersection calculations required; all decisions based on direct line value comparisons at integer coordinates.
\end{itemize}

The LICT's complexity depends on the coordinate range rather than the number of lines. This provides consistent performance regardless of hull size, though it cannot exploit cases where the hull remains small relative to the number of insertions.

\subsection{Comparison of Approaches}

Table~\ref{tab:comparison} summarizes the key differences between the Dynamic CHT and LICT.

\begin{table}[h]
\centering
\caption{Comparison of Dynamic CHT and Li Chao Tree}
\label{tab:comparison}
\begin{tabular}{@{}lcc@{}}
\toprule
\textbf{Characteristic} & \textbf{Dynamic CHT} & \textbf{LICT} \\
\midrule
Time Complexity & $O(\log n)$ amortized & $O(\log C)$ \\
Space Complexity & $O(n)$ & $O(N \log C)$ \\
Intersection Calculations & Required & None \\
Numerical Precision & Care required & Straightforward \\
Line Segment Extension & Complex & Natural \\
Persistence Support & Difficult & Straightforward \\
Implementation Complexity & Higher & Lower \\
\bottomrule
\end{tabular}
\end{table}

\section{Implementation}\label{sec:implementation}

We present streamlined implementations emphasizing clarity and correctness.

\subsection{Dynamic CHT}

Listing~\ref{lst:dcht} presents our Dynamic CHT implementation using \texttt{std::multiset}.

\begin{lstlisting}[language=C++, caption={Dynamic CHT Implementation}, label={lst:dcht}]
struct Line {
    mutable llint k, m, p;
    bool operator<(const Line& o) const { return k < o.k; }
    bool operator<(llint x) const { return p < x; }
};

struct LineContainer : multiset<Line, less<>> {
    static const llint inf = LLONG_MAX;
    
    llint div(llint a, llint b) {
        return a / b - ((a ^ b) < 0 && a % b);
    }
    
    bool isect(iterator x, iterator y) {
        if (y == end()) return x->p = inf, 0;
        if (x->k == y->k)
            x->p = x->m > y->m ? inf : -inf;
        else
            x->p = div(y->m - x->m, x->k - y->k);
        return x->p >= y->p;
    }
    
    void add(llint k, llint m) {
        auto z = insert({k, m, 0}), y = z++, x = y;
        while (isect(y, z)) z = erase(z);
        if (x != begin() && isect(--x, y))
            isect(x, y = erase(y));
        while ((y = x) != begin() && (--x)->p >= y->p)
            isect(x, erase(y));
    }
    
    llint query(llint x) {
        if (empty()) return 0;
        auto l = *lower_bound(x);
        return l.k * x + l.m;
    }
};
\end{lstlisting}

\subsection{Standard LICT}

Listing~\ref{lst:lichao} presents our Standard LICT implementation.

\begin{lstlisting}[language=C++, caption={Standard LICT Implementation}, label={lst:lichao}]
const llint INF = 4e18;

struct Line {
    llint k, m;
    llint eval(llint x) const { return k * x + m; }
};

struct Node {
    Line line;
    Node *left = nullptr, *right = nullptr;
    Node(Line l) : line(l) {}
};

class LiChaoTree {
    Node* root = nullptr;
    llint min_x, max_x;

    void insert(Node* &node, Line new_line, llint l, llint r) {
        if (!node) {
            node = new Node(new_line);
            return;
        }
        llint mid = l + (r - l) / 2;
        bool lef = new_line.eval(l) < node->line.eval(l);
        bool midf = new_line.eval(mid) < node->line.eval(mid);

        if (midf) swap(node->line, new_line);
        if (l == r) return;
        if (lef != midf)
            insert(node->left, new_line, l, mid);
        else
            insert(node->right, new_line, mid + 1, r);
    }

    llint query(Node* node, llint x, llint l, llint r) {
        if (!node) return INF;
        llint mid = l + (r - l) / 2;
        llint val = node->line.eval(x);
        if (l == r) return val;
        if (x <= mid)
            return min(val, query(node->left, x, l, mid));
        else
            return min(val, query(node->right, x, mid + 1, r));
    }

public:
    LiChaoTree(llint min_val = -1e9, llint max_val = 1e9)
        : min_x(min_val), max_x(max_val) {}

    void add_line(llint k, llint m) {
        insert(root, {k, m}, min_x, max_x);
    }

    llint query(llint x) {
        return query(root, x, min_x, max_x);
    }
};
\end{lstlisting}

\section{Benchmarks}\label{sec:benchmarks}

\subsection{Experimental Setup}

All benchmarks were conducted with the following configuration:
\begin{itemize}
    \item \textbf{Compiler:} g++ 11.4.0 with \texttt{-O3 -std=c++17}
    \item \textbf{Platform:} Linux x86\_64
    \item \textbf{Test sizes:} $10^5$, $10^6$, and $10^7$ operations
    \item \textbf{Distributions:}
    \begin{itemize}
        \item \textbf{Random:} Random slopes and intercepts. Expected hull size: $\Theta(\sqrt{N})$.
        \item \textbf{All on Hull:} Lines $y = i \cdot x - i^2$. All $N$ lines contribute to the hull.
    \end{itemize}
\end{itemize}

\subsection{Results}

Table~\ref{tab:results} presents the performance comparison.

\begin{table}[h]
\centering
\caption{Performance Comparison (Time in milliseconds)}
\label{tab:results}
\begin{tabular}{@{}ccccc@{}}
\toprule
\textbf{N} & \textbf{Distribution} & \textbf{LICT} & \textbf{Dynamic CHT} & \textbf{Ratio} \\
\midrule
$10^5$ & Random & 10 ms & 5 ms & $2.00\times$ \\
$10^5$ & All on Hull & 6 ms & 4 ms & $1.50\times$ \\
\midrule
$10^6$ & Random & 77 ms & 52 ms & $1.48\times$ \\
$10^6$ & All on Hull & 67 ms & 41 ms & $1.63\times$ \\
\midrule
$10^7$ & Random & 789 ms & 545 ms & $1.45\times$ \\
$10^7$ & All on Hull & 687 ms & 426 ms & $1.61\times$ \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Analysis}

The Dynamic CHT demonstrates consistently faster execution across all test cases, with performance advantage ranging from 1.45 to 2.00 times. The gap is most pronounced at smaller problem sizes and narrows as $N$ increases.

The relationship between hull size and performance exhibits scale dependent behavior. At smaller scales, the Dynamic CHT benefits more significantly from skipping irrelevant lines. At larger scales, cache effects become dominant, and the pattern becomes less pronounced.

Both implementations exhibit logarithmic scaling consistent with their theoretical complexity guarantees.

\section{Discussion}\label{sec:discussion}

\subsection{Advantages of the Li Chao Tree}

Despite higher computational cost, the LICT offers significant advantages for practical applications:

\textbf{1. Implementation Simplicity.} The LICT requires approximately half the code of the Dynamic CHT and eliminates complex geometric calculations. This reduces implementation time and probability of errors, particularly important in competitive programming and rapid prototyping contexts.

\textbf{2. Numerical Stability.} The LICT performs only integer addition and multiplication for line evaluation. The Dynamic CHT requires division for intersection calculations, necessitating careful handling of edge cases including parallel lines and overflow conditions.

\textbf{3. Extensibility.} The LICT's structure facilitates extensions that are difficult with the Dynamic CHT:
\begin{itemize}
    \item \textbf{Line Segments:} Lines valid only on subranges $[x_l, x_r]$ integrate naturally by limiting recursion bounds.
    \item \textbf{Persistence:} Path copying for versioned access requires minimal modification.
    \item \textbf{Higher Dimensions:} Generalization to multi dimensional query spaces follows naturally from the recursive structure.
\end{itemize}

\subsection{Selection Guidelines}

\textbf{Select LICT when:}
\begin{itemize}
    \item Implementation time and correctness are primary concerns
    \item Persistence or line segment support is required
    \item Working with integer coordinates exclusively
    \item The coordinate range is bounded and known
\end{itemize}

\textbf{Select Dynamic CHT when:}
\begin{itemize}
    \item Maximum query throughput is required
    \item The hull size is expected to remain small
    \item Implementation complexity can be managed
\end{itemize}

\section{Conclusion}\label{sec:conclusion}

This paper has presented a comprehensive analysis of the Li Chao Tree as an alternative to the Dynamic Convex Hull Trick for online line envelope maintenance. Our empirical evaluation confirms that the Dynamic CHT achieves superior raw performance, while the LICT provides advantages in implementation simplicity, numerical stability, and extensibility.

The Li Chao Tree represents a distinct point in the design space, trading constant factor performance for reduced implementation complexity and enhanced flexibility. For applications requiring persistence, line segment support, or rapid implementation, the LICT offers compelling advantages. For performance critical applications with bounded hull size, the Dynamic CHT remains preferable.

Since its introduction in 2012, the LICT has found widespread adoption in competitive programming and algorithmic education. Its continued relevance demonstrates that optimal asymptotic complexity is not the sole criterion for practical data structure selection; implementation clarity and extensibility play equally important roles in determining utility.

\begin{thebibliography}{4}

\bibitem{zjoi2012}
Li Chao.
\newblock Lecture at Zhejiang Provincial Olympiad in Informatics (ZJOI 2012).
\newblock China, 2012.

\bibitem{cp-algorithms}
CP-Algorithms.
\newblock Li Chao Tree.
\newblock \url{https://cp-algorithms.com/geometry/li_chao_tree.html}, 2024.

\bibitem{codeforces}
I\_LOVE\_TIGER.
\newblock Li Chao Tree Tutorial.
\newblock \url{https://codeforces.com/blog/entry/51275}, 2017.

\bibitem{kactl}
KTH Algorithm Library (KACTL).
\newblock LineContainer.
\newblock \url{https://github.com/kth-competitive-programming/kactl}, 2024.

\end{thebibliography}

\end{document}
