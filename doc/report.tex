\documentclass[11pt,a4paper]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{natbib}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}

\title{\textbf{The Li-Chao Tree: An Alternative Approach to Dynamic Line Container Queries}}
\author{Li Chao}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
The Li-Chao Tree (LICT) was informally introduced in a lecture in 2012 and subsequently gained widespread adoption in the competitive programming community as an alternative approach to online line container queries. Despite its practical utility, the structure has not been formally documented in the academic literature. This technical report aims to formalize the LICT and provide a comprehensive analysis comparing it to the Dynamic Convex Hull Trick (CHT). While the Dynamic CHT has traditionally been the standard solution, the LICT offers distinct advantages in implementation simplicity, numerical stability, and extensibility to advanced variants such as persistence and line segments.
\end{abstract}

\section{Introduction}

Dynamic line container maintenance is a fundamental problem in computational geometry with extensive applications in dynamic programming optimization, operations research, and computer graphics. The problem is defined as follows: given a dynamic set of linear functions $y = kx + m$, support efficient insertion of new lines and querying the minimum (or maximum) value at arbitrary $x$ coordinates.

Formally, we require a data structure supporting two operations:
\begin{enumerate}
    \item \textbf{Add Line:} Insert a new line $y = kx + m$ into the structure.
    \item \textbf{Query:} Given $x_0$, compute $\min_{i} \{k_i x_0 + m_i\}$ over all lines currently in the structure.
\end{enumerate}

Both operations must execute in logarithmic time $O(\log C)$ for the LICT (where $C$ is the coordinate range) to achieve acceptable performance for large-scale applications.

\subsection{Background}

The classical solution to this problem is the Convex Hull Trick (CHT), which maintains the lower envelope of lines explicitly. The Dynamic CHT variant uses a balanced binary search tree to support arbitrary insertion orders in $O(\log n)$ amortized time per operation. While asymptotically optimal, this approach requires complex intersection point calculations and careful handling of numerical precision.

In 2012, the Li-Chao Tree was informally presented in a lecture context and subsequently gained widespread adoption within the competitive programming community. Despite over a decade of practical use and its inclusion in standard algorithm libraries and educational materials, the structure has not been formally documented in the academic literature. This technical report, prepared in 2026, aims to address this gap by providing a formal treatment of the LICT, including precise algorithmic specifications, implementation details, and empirical performance analysis relative to the established Dynamic CHT baseline. We present clean, production-ready implementations suitable for educational and practical use, conduct systematic performance evaluation, analyze the theoretical and practical trade-offs with particular attention to extensibility features, and provide evidence-based guidelines for data structure selection.

\section{Related Work}\label{sec:related}

The Convex Hull Trick represents the classical approach to line container maintenance. We review the Dynamic CHT and related work to establish the context for the LICT.

Dynamic maintenance of geometric configurations has been studied extensively in computational geometry. Overmars and van Leeuwen \cite{overmars1981} presented foundational work on dynamic convex hull maintenance, demonstrating that the lower envelope of lines can be maintained efficiently using balanced binary search trees. Their work established the theoretical framework for dynamic geometric data structures.

\subsection{Dynamic Convex Hull Trick}

For arbitrary insertion sequences, a balanced binary search tree maintains the hull explicitly. Each insertion and query requires $O(\log n)$ amortized time. The implementation complexity stems from the need to compute and maintain intersection points between adjacent lines in the hull.

The Dynamic CHT requires computing intersection points as $x_{\text{intersect}} = \frac{m_2 - m_1}{k_1 - k_2}$, necessitating careful handling of division by zero (parallel lines), integer overflow, and sign conventions for floored division.

\section{Overview}\label{sec:lichao}

This section presents the Li-Chao Tree, the primary contribution of this paper.

\subsection{Algorithmic Approach}

The LICT offers a fundamentally different approach based on implicit envelope maintenance through interval subdivision. Rather than tracking the convex hull geometry explicitly, the structure maintains the optimal line at each interval midpoint, recursively partitioning the query range.

Each node in the tree represents an interval $[l, r]$ and stores the line that is locally optimal at the midpoint $m = \lfloor(l+r)/2\rfloor$ among all lines that have traversed that node during insertion. A line is locally optimal at $m$ if it yields the minimum value at $m$ compared to all other lines that have been compared at this specific node. Note that this line is not necessarily globally optimal at $m$, as other lines may have been routed to different branches of the tree based on their performance at other midpoints.

Insertion proceeds by comparing the new line with the stored line at each node: if the new line is better at the midpoint, the lines are swapped and the worse line continues down the appropriate child interval. The key geometric insight is that two distinct lines intersect at most once. Therefore, if a line is worse at the midpoint, it can be better than the stored line on at most one side of the midpoint, never both. This property guarantees that the worse line need only be propagated down a single child path, ensuring the algorithm terminates in $O(\log C)$ steps.

The appropriate child is determined by where the relative ordering changes: if the ordering between the new line and the stored line changes between the left endpoint and the midpoint (i.e., the new line is better at $l$ but worse at $m$, or vice versa), we recurse on the left child; otherwise, we recurse on the right child. This follows directly from the single-intersection property: the crossing point, if it exists, must lie on the side where the ordering changes.

\begin{itemize}
    \item \textbf{Time Complexity:} $O(\log C)$ per operation, where $C$ represents the coordinate range (typically $C \approx 10^9$ for 32-bit integers).
    \item \textbf{Space Complexity:} At most $O(n \log C)$ nodes in the worst case when all lines follow disjoint paths through the tree. In practice, heavy node sharing occurs as lines with similar slopes traverse common paths, typically resulting in significantly lower memory usage.
    \item \textbf{Key Characteristics:} No intersection calculations required; all decisions based on direct line value comparisons at integer coordinates.
\end{itemize}

\textbf{Deletion.} Unlike the Dynamic CHT, which can support deletion of arbitrary lines in $O(\log n)$ time, the standard LICT does not support efficient deletion. Removing a line would require traversing all nodes where that line might be stored and recomputing optimal lines from descendants, which is computationally expensive. For applications requiring deletion, alternative approaches include segment tree beats or reconstructing the tree periodically.

The LICT's complexity depends on the coordinate range rather than the number of lines. This provides consistent performance regardless of hull size, though it cannot exploit cases where the hull remains small relative to the number of insertions.

\subsection{Comparison with Dynamic CHT}

Table~\ref{tab:comparison} summarizes the key differences between the Dynamic CHT and LICT.

\begin{table}[h]
\centering
\caption{Comparison of Dynamic CHT and Li-Chao Tree}
\label{tab:comparison}
\begin{tabular}{@{}lcc@{}}
\toprule
\textbf{Characteristic} & \textbf{Dynamic CHT} & \textbf{LICT} \\
\midrule
Time Complexity & $O(\log n)$ amortized & $O(\log C)$ \\
Space Complexity & $O(n)$ & $O(n \log C)$ worst case \\
Intersection Calculations & Required & None \\
Numerical Precision & Care required & Straightforward \\
Line Segment Extension & Complex & Natural \\
Persistence Support & Difficult & Straightforward \\
Implementation Complexity & Higher & Lower \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Key Trade-offs}

The choice between these approaches involves several trade-offs:

\textbf{Performance versus simplicity.} The Dynamic CHT achieves faster query and insertion times, particularly when the hull size remains small relative to the number of insertions. The LICT trades this performance for implementation simplicity and reduced code complexity.

\textbf{Geometric versus combinatorial.} The Dynamic CHT relies on geometric calculations (intersection points) that require careful numerical handling. The LICT uses only combinatorial operations (line evaluations at integer coordinates), avoiding precision concerns.

\textbf{Static versus extensible.} The Dynamic CHT's explicit hull structure makes extensions such as persistence and line segments difficult. The LICT's recursive tree structure naturally accommodates these extensions.

\subsection{Summary of Results}

Our empirical evaluation (detailed in Section~\ref{sec:benchmarks}) confirms that the Dynamic CHT achieves approximately 1.45 to 2.00 times faster execution across problem scales ranging from $10^5$ to $10^7$ operations. However, the LICT's implementation requires roughly half the code and eliminates an entire class of potential bugs related to intersection calculations. For applications where implementation time, correctness guarantees, or extensibility are paramount, the LICT offers a compelling alternative despite its higher computational cost.

\section{Implementation}\label{sec:implementation}

We present streamlined implementations emphasizing clarity and correctness.

\subsection{Dynamic CHT}

Listing~\ref{lst:dcht} presents our Dynamic CHT implementation using \texttt{std::multiset}.

\begin{lstlisting}[language=C++, caption={Dynamic CHT Implementation}, label={lst:dcht}]
struct Line {
    mutable llint k, m, p;
    bool operator<(const Line& o) const { return k < o.k; }
    bool operator<(llint x) const { return p < x; }
};

struct LineContainer : multiset<Line, less<>> {
    static const llint inf = LLONG_MAX;
    
    llint div(llint a, llint b) {
        return a / b - ((a ^ b) < 0 && a % b);
    }
    
    bool isect(iterator x, iterator y) {
        if (y == end()) return x->p = inf, 0;
        if (x->k == y->k)
            x->p = x->m > y->m ? inf : -inf;
        else
            x->p = div(y->m - x->m, x->k - y->k);
        return x->p >= y->p;
    }
    
    void add(llint k, llint m) {
        auto z = insert({k, m, 0}), y = z++, x = y;
        while (isect(y, z)) z = erase(z);
        if (x != begin() && isect(--x, y))
            isect(x, y = erase(y));
        while ((y = x) != begin() && (--x)->p >= y->p)
            isect(x, erase(y));
    }
    
    // Query returns 0 if the container is empty. Caller should check
    // empty() first if a different default value is required.
    llint query(llint x) {
        if (empty()) return 0;
        auto l = *lower_bound(x);
        return l.k * x + l.m;
    }
};
\end{lstlisting}

\subsection{Standard LICT}

Listing~\ref{lst:lichao} presents our Standard LICT implementation.

\begin{lstlisting}[language=C++, caption={Standard LICT Implementation}, label={lst:lichao}]
// INF must be larger than any possible query result. With k, x, m bounded
// such that |k*x + m| < 4e18, this value ensures min() operations work correctly.
// For 64-bit signed integers, LLONG_MAX = 9.22e18, so 4e18 is safe.
const llint INF = 4e18;

struct Line {
    llint k, m;
    // Evaluates the line at coordinate x. 
    // WARNING: k * x + m can overflow 64-bit integers. Use __int128 for
    // intermediate calculation if |k|, |x|, |m| may exceed ~3e9, or ensure
    // input ranges are bounded appropriately.
    llint eval(llint x) const { return k * x + m; }
};

struct Node {
    Line line;
    Node *left = nullptr, *right = nullptr;
    Node(Line l) : line(l) {}
};

class LiChaoTree {
    Node* root = nullptr;
    llint min_x, max_x;

    void insert(Node* &node, Line new_line, llint l, llint r) {
        if (!node) {
            node = new Node(new_line);
            return;
        }
        llint mid = l + (r - l) / 2;
        bool lef = new_line.eval(l) < node->line.eval(l);
        bool midf = new_line.eval(mid) < node->line.eval(mid);

        if (midf) swap(node->line, new_line);
        if (l == r) return;
        if (lef != midf)
            insert(node->left, new_line, l, mid);
        else
            insert(node->right, new_line, mid + 1, r);
    }

    llint query(Node* node, llint x, llint l, llint r) {
        if (!node) return INF;
        llint mid = l + (r - l) / 2;
        llint val = node->line.eval(x);
        if (l == r) return val;
        if (x <= mid)
            return min(val, query(node->left, x, l, mid));
        else
            return min(val, query(node->right, x, mid + 1, r));
    }

public:
    LiChaoTree(llint min_val = -1e9, llint max_val = 1e9)
        : min_x(min_val), max_x(max_val) {}

    void add_line(llint k, llint m) {
        insert(root, {k, m}, min_x, max_x);
    }

    // Query returns INF if the tree is empty (no lines inserted).
    // Caller should check for this condition if empty tree is possible.
    llint query(llint x) {
        return query(root, x, min_x, max_x);
    }
};
\end{lstlisting}

\subsection{Empty Container Behavior}

The implementations differ in their handling of empty container queries. The Dynamic CHT returns 0 when empty, while the LICT returns $\texttt{INF}$ (a sentinel value larger than any valid query result). This difference reflects typical usage patterns: the Dynamic CHT often appears in competitive programming contexts where 0 is a natural default (e.g., maximizing DP transitions), while the LICT's INF return makes explicit that no lines have been inserted. Callers should check \texttt{empty()} or handle the sentinel value appropriately based on application requirements.

\section{Benchmarks}\label{sec:benchmarks}

To validate the theoretical complexity analysis and characterize practical performance differences between the two approaches, we conducted systematic empirical evaluation across varying problem scales and input distributions.

\subsection{Experimental Setup}

All benchmarks were conducted with the following configuration:
\begin{itemize}
    \item \textbf{Compiler:} g++ 11.4.0 with \texttt{-O3 -std=c++17}
    \item \textbf{Platform:} Linux x86\_64
    \item \textbf{Test sizes:} $10^5$, $10^6$, and $10^7$ operations
    \item \textbf{Coordinate range:} $C = 10^9$, with $x, k, m \in [-10^9, 10^9]$
    \item \textbf{Random seed:} 42 (fixed for reproducibility)
    \item \textbf{Measurement protocol:} Each test was run 10 times; reported times are the median. Variance was low ($<5\%$ coefficient of variation across runs). Benchmarks were run on an isolated system with no other user processes to minimize timing noise.
    \item \textbf{Distributions:}
    \begin{itemize}
        \item \textbf{Random:} Slopes $k \sim U(-10^9, 10^9)$, intercepts $m \sim U(-10^9, 10^9)$. Expected hull size: $\Theta(\sqrt{n})$.
        \item \textbf{All on Hull:} Lines $y = i \cdot x - i^2$ for $i \in [1, n]$. All $n$ lines contribute to the hull.
    \end{itemize}
\end{itemize}

\subsection{Results}

Table~\ref{tab:results} presents the performance comparison.

\begin{table}[h]
\centering
\caption{Performance Comparison (Time in milliseconds)}
\label{tab:results}
\begin{tabular}{@{}ccccc@{}}
\toprule
\textbf{N} & \textbf{Distribution} & \textbf{LICT} & \textbf{Dynamic CHT} & \textbf{Ratio} \\
\midrule
$10^5$ & Random & 10 ms & 5 ms & $2.00\times$ \\
$10^5$ & All on Hull & 6 ms & 4 ms & $1.50\times$ \\
\midrule
$10^6$ & Random & 77 ms & 52 ms & $1.48\times$ \\
$10^6$ & All on Hull & 67 ms & 41 ms & $1.63\times$ \\
\midrule
$10^7$ & Random & 789 ms & 545 ms & $1.45\times$ \\
$10^7$ & All on Hull & 687 ms & 426 ms & $1.61\times$ \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Analysis}

The Dynamic CHT demonstrates consistently faster execution across all test cases, with performance advantage ranging from 1.45 to 2.00 times. The gap is most pronounced at smaller problem sizes and narrows as $N$ increases.

The relationship between hull size and performance exhibits scale-dependent behavior. At smaller scales, the Dynamic CHT benefits more significantly from skipping irrelevant lines. At larger scales, cache effects become dominant, and the pattern becomes less pronounced.

Both implementations exhibit logarithmic scaling consistent with their theoretical complexity guarantees.

\section{Discussion}\label{sec:discussion}

\subsection{Advantages of the Li-Chao Tree}

Despite higher computational cost, the LICT offers significant advantages for practical applications:

\textbf{1. Implementation simplicity.} The LICT requires approximately half the code of the Dynamic CHT (45 lines vs.~88 lines in our implementations) and eliminates complex geometric calculations. This reduces implementation time and probability of errors, particularly important in competitive programming and rapid prototyping contexts.

\textbf{2. Numerical stability.} The LICT performs only integer addition and multiplication for line evaluation. The Dynamic CHT requires division for intersection calculations, necessitating careful handling of edge cases including parallel lines and overflow conditions.

\textbf{3. Floating-point queries.} For non-integer (floating-point) query coordinates, the LICT complexity becomes $O(\log(C/\epsilon))$ where $\epsilon$ is the required precision. With coordinate range $10^9$ and double precision ($\epsilon \approx 10^{-9}$), the tree depth increases from approximately 30 to 60. In such cases, the Dynamic CHT's $O(\log n)$ complexity (independent of coordinate precision) becomes relatively more attractive. For applications requiring both floating-point coordinates and the LICT's implementation advantages, one may use $\epsilon = 1$ as the smallest representable unit after appropriate coordinate transformation.

\textbf{4. Extensibility.} The LICT's structure facilitates extensions that are difficult with the Dynamic CHT:
\begin{itemize}
    \item \textbf{Line segments:} Lines valid only on subranges $[x_l, x_r]$ integrate naturally by limiting recursion bounds.
    \item \textbf{Persistence:} Path copying for versioned access requires minimal modification.
    \item \textbf{Higher dimensions:} Generalization to multi-dimensional query spaces follows naturally from the recursive structure.
\end{itemize}

\section{Conclusion}\label{sec:conclusion}

This paper has presented a comprehensive analysis of the Li-Chao Tree as an alternative to the Dynamic Convex Hull Trick for online line container queries. Our empirical evaluation confirms that the Dynamic CHT achieves superior raw performance, while the LICT provides advantages in implementation simplicity, numerical stability, and extensibility.

The Li Chao Tree represents a distinct point in the design space, trading constant factor performance for reduced implementation complexity and enhanced flexibility. For applications requiring persistence, line segment support, or rapid implementation, the LICT offers compelling advantages. For performance-critical applications with bounded hull size, the Dynamic CHT remains preferable.

Since its introduction in 2012, the Li-Chao Tree has found widespread adoption in competitive programming and algorithmic education. Its continued relevance demonstrates that optimal asymptotic complexity is not the sole criterion for practical data structure selection; implementation clarity and extensibility play equally important roles in determining utility.

\begin{thebibliography}{5}

\bibitem{overmars1981}
Overmars, M.H. and van Leeuwen, J.
\newblock Maintenance of configurations in the plane.
\newblock \emph{Journal of Computer and System Sciences}, 23(2):166--204, 1981.

\bibitem{zjoi2012}
Li Chao.
\newblock Lecture at Zhejiang Provincial Olympiad in Informatics (ZJOI 2012).
\newblock China, 2012.

\bibitem{cp-algorithms}
CP-Algorithms.
\newblock Li Chao Tree.
\newblock \url{https://cp-algorithms.com/geometry/li_chao_tree.html}, 2024.

\bibitem{codeforces}
I\_LOVE\_TIGER.
\newblock Li Chao Tree Tutorial.
\newblock \url{https://codeforces.com/blog/entry/51275}, 2017.

\bibitem{kactl}
KTH Algorithm Library (KACTL).
\newblock LineContainer.
\newblock \url{https://github.com/kth-competitive-programming/kactl}, 2024.

\end{thebibliography}

\end{document}
