\documentclass[11pt,a4paper]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{natbib}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}

\title{\textbf{The Li-Chao Tree: An Alternative Approach to Dynamic Line Envelope Maintenance}}
\author{Li Chao}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
The Li-Chao Tree (LICT) was informally introduced in a lecture in 2012 and subsequently gained widespread adoption in the competitive programming community as an alternative approach to online line envelope maintenance. Despite its practical utility, the structure has not been formally documented in the academic literature. This paper, written in 2026, aims to formalize the LICT and provide a comprehensive analysis comparing it to the Dynamic Convex Hull Trick (CHT). While the Dynamic CHT has traditionally been the standard solution, the LICT offers distinct advantages in implementation simplicity, numerical stability, and extensibility to advanced variants such as persistence and line segments. Our empirical evaluation indicates that the Dynamic CHT achieves approximately 1.5 to 2.0 times faster execution in standard benchmarks, while the LICT provides superior ease of implementation and greater flexibility for extensions. We offer practical guidance for selecting the appropriate data structure based on application requirements.
\end{abstract}

\section{Introduction}

Dynamic line envelope maintenance is a fundamental problem in computational geometry with extensive applications in dynamic programming optimization, operations research, and computer graphics. The problem is defined as follows: given a dynamic set of linear functions $y = kx + m$, support efficient insertion of new lines and querying the minimum (or maximum) value at arbitrary $x$ coordinates.

Formally, we require a data structure supporting two operations:
\begin{enumerate}
    \item \textbf{Add Line:} Insert a new line $y = kx + m$ into the structure.
    \item \textbf{Query:} Given $x_0$, compute $\min_{i} \{k_i x_0 + m_i\}$ over all lines currently in the structure.
\end{enumerate}

Both operations must execute in logarithmic time to achieve acceptable performance for large-scale applications.

\subsection{Background and Motivation}

The classical solution to this problem is the Convex Hull Trick (CHT), which maintains the lower envelope of lines explicitly. The Dynamic CHT variant uses a balanced binary search tree to support arbitrary insertion orders in $O(\log n)$ amortized time per operation. While asymptotically optimal, this approach requires complex intersection point calculations and careful handling of numerical precision.

In 2012, the Li-Chao Tree was informally presented in a lecture context and subsequently gained widespread adoption within the competitive programming community. Despite over a decade of practical use and its inclusion in standard algorithm libraries and educational materials, the structure has not been formally documented in the peer reviewed literature. This paper, prepared in 2026, aims to address this gap by providing a formal treatment of the LICT, including precise algorithmic specifications, implementation details, and empirical performance analysis relative to the established Dynamic CHT baseline.

\subsection{Contributions}

This paper makes the following contributions:
\begin{enumerate}
    \item We present clean, production ready implementations of both the Standard LICT and Dynamic CHT, suitable for educational and practical use.
    \item We conduct systematic performance evaluation comparing both approaches across multiple problem scales and data distributions.
    \item We analyze the theoretical and practical trade offs between the two data structures, with particular attention to extensibility features including persistence, line segment support, and higher dimensional generalizations.
    \item We provide evidence based guidelines for selecting the appropriate data structure for specific application contexts.
\end{enumerate}

\section{Related Work}\label{sec:related}

The Convex Hull Trick represents the classical approach to line envelope maintenance. We review its variants to establish the context for the LICT.

\subsection{Convex Hull Trick}

The Convex Hull Trick encompasses two primary variants with different applicability constraints.

\textbf{1. Monotonic CHT:} When lines are inserted in order of monotonic slope, the lower hull can be maintained in a deque, achieving $O(1)$ amortized time per operation for both insertions and queries. This variant is highly efficient when applicable but fails for arbitrary insertion orders.

\textbf{2. Dynamic CHT:} For arbitrary insertion sequences, a balanced binary search tree maintains the hull explicitly. Each insertion and query requires $O(\log n)$ amortized time. The implementation complexity stems from the need to compute and maintain intersection points between adjacent lines in the hull.

The Dynamic CHT requires computing intersection points as $x_{\text{intersect}} = \frac{m_2 - m_1}{k_1 - k_2}$, necessitating careful handling of division by zero (parallel lines), integer overflow, and sign conventions for floored division.

\section{The Li-Chao Tree}\label{sec:lichao}

This section presents the Li-Chao Tree, the primary contribution of this paper.

\subsection{Algorithmic Approach}

The LICT offers a fundamentally different approach based on implicit envelope maintenance through interval subdivision. Rather than tracking the convex hull geometry explicitly, the structure maintains the optimal line at each interval midpoint, recursively partitioning the query range.

Each node in the tree represents an interval $[l, r]$ and stores the line optimal at the midpoint. Insertion proceeds by comparing the new line with the stored line at each node: if the new line is better at the midpoint, the lines are swapped and the worse line continues down the appropriate child interval. This approach eliminates intersection calculations entirely, at the cost of exploring the full tree height regardless of hull size.

\begin{itemize}
    \item \textbf{Time Complexity:} $O(\log C)$ per operation, where $C$ represents the coordinate range (typically $C \approx 10^9$ for 32 bit integers).
    \item \textbf{Space Complexity:} $O(N \log C)$ for $N$ inserted lines, with dynamic node creation ensuring only visited nodes are allocated.
    \item \textbf{Key Characteristics:} No intersection calculations required; all decisions based on direct line value comparisons at integer coordinates.
\end{itemize}

The LICT's complexity depends on the coordinate range rather than the number of lines. This provides consistent performance regardless of hull size, though it cannot exploit cases where the hull remains small relative to the number of insertions.

\subsection{Comparison with Dynamic CHT}

Table~\ref{tab:comparison} summarizes the key differences between the Dynamic CHT and LICT.

\begin{table}[h]
\centering
\caption{Comparison of Dynamic CHT and Li Chao Tree}
\label{tab:comparison}
\begin{tabular}{@{}lcc@{}}
\toprule
\textbf{Characteristic} & \textbf{Dynamic CHT} & \textbf{LICT} \\
\midrule
Time Complexity & $O(\log n)$ amortized & $O(\log C)$ \\
Space Complexity & $O(n)$ & $O(N \log C)$ \\
Intersection Calculations & Required & None \\
Numerical Precision & Care required & Straightforward \\
Line Segment Extension & Complex & Natural \\
Persistence Support & Difficult & Straightforward \\
Implementation Complexity & Higher & Lower \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Key Trade-offs}

The choice between these approaches involves several trade-offs:

\textbf{Performance versus Simplicity.} The Dynamic CHT achieves faster query and insertion times, particularly when the hull size remains small relative to the number of insertions. The LICT trades this performance for implementation simplicity and reduced code complexity.

\textbf{Geometric versus Combinatorial.} The Dynamic CHT relies on geometric calculations (intersection points) that require careful numerical handling. The LICT uses only combinatorial operations (line evaluations at integer coordinates), avoiding precision concerns.

\textbf{Static versus Extensible.} The Dynamic CHT's explicit hull structure makes extensions such as persistence and line segments difficult. The LICT's recursive tree structure naturally accommodates these extensions.

\subsection{Summary of Results}

Our empirical evaluation (detailed in Section~\ref{sec:benchmarks}) confirms that the Dynamic CHT achieves approximately 1.45 to 2.00 times faster execution across problem scales ranging from $10^5$ to $10^7$ operations. However, the LICT's implementation requires roughly half the code and eliminates an entire class of potential bugs related to intersection calculations. For applications where implementation time, correctness guarantees, or extensibility are paramount, the LICT offers a compelling alternative despite its higher computational cost.

\section{Implementation}\label{sec:implementation}

We present streamlined implementations emphasizing clarity and correctness.

\subsection{Dynamic CHT}

Listing~\ref{lst:dcht} presents our Dynamic CHT implementation using \texttt{std::multiset}.

\begin{lstlisting}[language=C++, caption={Dynamic CHT Implementation}, label={lst:dcht}]
struct Line {
    mutable llint k, m, p;
    bool operator<(const Line& o) const { return k < o.k; }
    bool operator<(llint x) const { return p < x; }
};

struct LineContainer : multiset<Line, less<>> {
    static const llint inf = LLONG_MAX;
    
    llint div(llint a, llint b) {
        return a / b - ((a ^ b) < 0 && a % b);
    }
    
    bool isect(iterator x, iterator y) {
        if (y == end()) return x->p = inf, 0;
        if (x->k == y->k)
            x->p = x->m > y->m ? inf : -inf;
        else
            x->p = div(y->m - x->m, x->k - y->k);
        return x->p >= y->p;
    }
    
    void add(llint k, llint m) {
        auto z = insert({k, m, 0}), y = z++, x = y;
        while (isect(y, z)) z = erase(z);
        if (x != begin() && isect(--x, y))
            isect(x, y = erase(y));
        while ((y = x) != begin() && (--x)->p >= y->p)
            isect(x, erase(y));
    }
    
    llint query(llint x) {
        if (empty()) return 0;
        auto l = *lower_bound(x);
        return l.k * x + l.m;
    }
};
\end{lstlisting}

\subsection{Standard LICT}

Listing~\ref{lst:lichao} presents our Standard LICT implementation.

\begin{lstlisting}[language=C++, caption={Standard LICT Implementation}, label={lst:lichao}]
const llint INF = 4e18;

struct Line {
    llint k, m;
    llint eval(llint x) const { return k * x + m; }
};

struct Node {
    Line line;
    Node *left = nullptr, *right = nullptr;
    Node(Line l) : line(l) {}
};

class LiChaoTree {
    Node* root = nullptr;
    llint min_x, max_x;

    void insert(Node* &node, Line new_line, llint l, llint r) {
        if (!node) {
            node = new Node(new_line);
            return;
        }
        llint mid = l + (r - l) / 2;
        bool lef = new_line.eval(l) < node->line.eval(l);
        bool midf = new_line.eval(mid) < node->line.eval(mid);

        if (midf) swap(node->line, new_line);
        if (l == r) return;
        if (lef != midf)
            insert(node->left, new_line, l, mid);
        else
            insert(node->right, new_line, mid + 1, r);
    }

    llint query(Node* node, llint x, llint l, llint r) {
        if (!node) return INF;
        llint mid = l + (r - l) / 2;
        llint val = node->line.eval(x);
        if (l == r) return val;
        if (x <= mid)
            return min(val, query(node->left, x, l, mid));
        else
            return min(val, query(node->right, x, mid + 1, r));
    }

public:
    LiChaoTree(llint min_val = -1e9, llint max_val = 1e9)
        : min_x(min_val), max_x(max_val) {}

    void add_line(llint k, llint m) {
        insert(root, {k, m}, min_x, max_x);
    }

    llint query(llint x) {
        return query(root, x, min_x, max_x);
    }
};
\end{lstlisting}

\section{Benchmarks}\label{sec:benchmarks}

\subsection{Experimental Setup}

All benchmarks were conducted with the following configuration:
\begin{itemize}
    \item \textbf{Compiler:} g++ 11.4.0 with \texttt{-O3 -std=c++17}
    \item \textbf{Platform:} Linux x86\_64
    \item \textbf{Test sizes:} $10^5$, $10^6$, and $10^7$ operations
    \item \textbf{Distributions:}
    \begin{itemize}
        \item \textbf{Random:} Random slopes and intercepts. Expected hull size: $\Theta(\sqrt{N})$.
        \item \textbf{All on Hull:} Lines $y = i \cdot x - i^2$. All $N$ lines contribute to the hull.
    \end{itemize}
\end{itemize}

\subsection{Results}

Table~\ref{tab:results} presents the performance comparison.

\begin{table}[h]
\centering
\caption{Performance Comparison (Time in milliseconds)}
\label{tab:results}
\begin{tabular}{@{}ccccc@{}}
\toprule
\textbf{N} & \textbf{Distribution} & \textbf{LICT} & \textbf{Dynamic CHT} & \textbf{Ratio} \\
\midrule
$10^5$ & Random & 10 ms & 5 ms & $2.00\times$ \\
$10^5$ & All on Hull & 6 ms & 4 ms & $1.50\times$ \\
\midrule
$10^6$ & Random & 77 ms & 52 ms & $1.48\times$ \\
$10^6$ & All on Hull & 67 ms & 41 ms & $1.63\times$ \\
\midrule
$10^7$ & Random & 789 ms & 545 ms & $1.45\times$ \\
$10^7$ & All on Hull & 687 ms & 426 ms & $1.61\times$ \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Analysis}

The Dynamic CHT demonstrates consistently faster execution across all test cases, with performance advantage ranging from 1.45 to 2.00 times. The gap is most pronounced at smaller problem sizes and narrows as $N$ increases.

The relationship between hull size and performance exhibits scale dependent behavior. At smaller scales, the Dynamic CHT benefits more significantly from skipping irrelevant lines. At larger scales, cache effects become dominant, and the pattern becomes less pronounced.

Both implementations exhibit logarithmic scaling consistent with their theoretical complexity guarantees.

\section{Discussion}\label{sec:discussion}

\subsection{Advantages of the Li Chao Tree}

Despite higher computational cost, the LICT offers significant advantages for practical applications:

\textbf{1. Implementation Simplicity.} The LICT requires approximately half the code of the Dynamic CHT and eliminates complex geometric calculations. This reduces implementation time and probability of errors, particularly important in competitive programming and rapid prototyping contexts.

\textbf{2. Numerical Stability.} The LICT performs only integer addition and multiplication for line evaluation. The Dynamic CHT requires division for intersection calculations, necessitating careful handling of edge cases including parallel lines and overflow conditions.

\textbf{3. Floating-Point Queries.} For non-integer (floating-point) query coordinates, the LICT complexity becomes $O(\log(C/\epsilon))$ where $\epsilon$ is the required precision. With coordinate range $10^9$ and double precision ($\epsilon \approx 10^{-9}$), the tree depth increases from approximately 30 to 60. In such cases, the Dynamic CHT's $O(\log n)$ complexity (independent of coordinate precision) becomes relatively more attractive. For applications requiring both floating-point coordinates and the LICT's implementation advantages, one may use $\epsilon = 1$ as the smallest representable unit after appropriate coordinate transformation.

\textbf{4. Extensibility.} The LICT's structure facilitates extensions that are difficult with the Dynamic CHT:
\begin{itemize}
    \item \textbf{Line Segments:} Lines valid only on subranges $[x_l, x_r]$ integrate naturally by limiting recursion bounds.
    \item \textbf{Persistence:} Path copying for versioned access requires minimal modification.
    \item \textbf{Higher Dimensions:} Generalization to multi dimensional query spaces follows naturally from the recursive structure.
\end{itemize}

\subsection{Selection Guidelines}

\textbf{Select LICT when:}
\begin{itemize}
    \item Implementation time and correctness are primary concerns
    \item Persistence or line segment support is required
    \item Working with integer coordinates exclusively
    \item The coordinate range is bounded and known
\end{itemize}

\textbf{Select Dynamic CHT when:}
\begin{itemize}
    \item Maximum query throughput is required
    \item The hull size is expected to remain small
    \item Implementation complexity can be managed
\end{itemize}

\section{Conclusion}\label{sec:conclusion}

This paper has presented a comprehensive analysis of the Li Chao Tree as an alternative to the Dynamic Convex Hull Trick for online line envelope maintenance. Our empirical evaluation confirms that the Dynamic CHT achieves superior raw performance, while the LICT provides advantages in implementation simplicity, numerical stability, and extensibility.

The Li Chao Tree represents a distinct point in the design space, trading constant factor performance for reduced implementation complexity and enhanced flexibility. For applications requiring persistence, line segment support, or rapid implementation, the LICT offers compelling advantages. For performance critical applications with bounded hull size, the Dynamic CHT remains preferable.

Since its introduction in 2012, the LICT has found widespread adoption in competitive programming and algorithmic education. Its continued relevance demonstrates that optimal asymptotic complexity is not the sole criterion for practical data structure selection; implementation clarity and extensibility play equally important roles in determining utility.

\begin{thebibliography}{4}

\bibitem{zjoi2012}
Li Chao.
\newblock Lecture at Zhejiang Provincial Olympiad in Informatics (ZJOI 2012).
\newblock China, 2012.

\bibitem{cp-algorithms}
CP-Algorithms.
\newblock Li Chao Tree.
\newblock \url{https://cp-algorithms.com/geometry/li_chao_tree.html}, 2024.

\bibitem{codeforces}
I\_LOVE\_TIGER.
\newblock Li Chao Tree Tutorial.
\newblock \url{https://codeforces.com/blog/entry/51275}, 2017.

\bibitem{kactl}
KTH Algorithm Library (KACTL).
\newblock LineContainer.
\newblock \url{https://github.com/kth-competitive-programming/kactl}, 2024.

\end{thebibliography}

\end{document}
