\documentclass[11pt,a4paper]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{natbib}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}

\title{\textbf{The Li-Chao tree: An Alternative Approach to Dynamic Maintenance of the Lower Envelope}}
\author{Li Chao}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
The Li-Chao tree (LICT) was informally introduced in a lecture in 2012 and subsequently gained widespread adoption in the competitive programming community for dynamic maintenance of the lower (or upper) envelope of a set of lines. Despite its practical utility, the structure has not been formally documented in the academic literature. This technical report formalizes the LICT and provides a comprehensive analysis of its properties and performance. The LICT offers distinct advantages in implementation simplicity, numerical stability, and extensibility to advanced variants such as persistence and line segments.
\end{abstract}

\section{Introduction}

Dynamic Lower Envelope maintenance is a fundamental problem in computational geometry with extensive applications. This technical report focuses on the Li-Chao tree (LICT), a data structure that maintains a set of linear functions while supporting insertion and query operations. The problem is defined as follows: given a dynamic set of linear functions $y = kx + b$, support efficient insertion of new lines and querying the minimum (or equivalently, maximum) value at arbitrary $x$ coordinates. This report focuses on minimum queries; maximum queries are obtained by negating line parameters.

Formally, we require a data structure supporting two operations:
\begin{enumerate}
    \item \textbf{Add Line:} Insert a new line $y = kx + b$ into the structure.
    \item \textbf{Query:} Given $x_0$, compute $\min_{i} \{k_i x_0 + b_i\}$ over all lines currently in the structure.
\end{enumerate}

The structure also supports line segments (lines defined only on finite intervals $[x_l, x_r]$) in addition to infinite lines.

Both operations must execute in logarithmic time for acceptable performance at scale. The LICT provides $O(\log C)$ time per operation for minimum (or maximum) queries, where $C = \frac{\text{coordinate range}}{\text{precision level}}$ represents the ratio of the coordinate range to the precision level. For integer coordinates with range $[0, 10^9]$, $C = 10^9$; for the same range with precision $10^{-6}$, $C = 10^{15}$.

\subsection{Background}

The classical solution to this problem is the Convex Hull Trick (CHT), which maintains the lower envelope of lines explicitly. Existing variants use balanced binary search trees or specialized structures to achieve logarithmic-time operations. While asymptotically optimal, these approaches require complex intersection point calculations and careful handling of numerical precision.

In 2012, the Li-Chao tree was presented informally in a lecture context.\footnote{The data structure is conventionally referred to as the ``Li-Chao tree'' in the literature and competitive programming community.} It subsequently gained widespread adoption within the competitive programming community. Despite over a decade of practical use and its inclusion in standard algorithm libraries, the structure has not been formally documented in the academic literature. This technical report addresses this gap by providing precise algorithmic specifications, implementation details, and empirical performance analysis of the LICT. We present well-tested reference implementations and conduct systematic performance evaluation with particular attention to extensibility features.

\section{Related Work}\label{sec:related}

Several approaches exist for Dynamic Lower Envelope maintenance, each with distinct trade-offs in terms of time complexity, implementation complexity, and applicability constraints. We review these solutions to establish the context for the LICT.

Dynamic maintenance of geometric configurations has been studied extensively in computational geometry.

\subsection{Overmars and van Leeuwen (1981)}

Overmars and van Leeuwen \cite{overmars1981} presented foundational work on dynamic convex hull maintenance. Their data structure supports insertion and deletion of lines while maintaining the lower envelope, enabling efficient querying of the minimum value at any point.

Their approach uses a balanced binary search tree to explicitly maintain the convex hull. Each node stores a line, and the tree is ordered by slope. Intersection points between adjacent lines are computed to determine the hull structure. Queries take $O(\log n)$ time, while insertions and deletions require $O(\log^2 n)$ time. The space complexity is $O(n)$, storing each inserted line exactly once.

Their work established the theoretical framework for dynamic geometric data structures and demonstrated that logarithmic-time dynamic maintenance of the lower envelope is achievable.

\subsection{Monotonic Convex Hull Trick}

When insertions arrive in order of monotonically increasing (or decreasing) slopes, a deque-based approach achieves $O(1)$ amortized time per insertion and $O(1)$ amortized time per query. This variant, widely used in dynamic programming optimization, maintains the convex hull incrementally without requiring balanced tree structures. However, the monotonicity restriction limits its applicability to problems where line slopes are known to follow a specific order.

\subsection{Dynamic Convex Hull Trick}

For arbitrary insertion sequences without monotonicity constraints, a balanced binary search tree maintains the hull explicitly. Each insertion and query requires $O(\log n)$ amortized time. The implementation complexity stems from the need to compute and maintain intersection points between adjacent lines in the hull.

The Dynamic CHT requires computing intersection points between adjacent lines in the hull as $x_{\text{intersect}} = \frac{b_2 - b_1}{k_1 - k_2}$, necessitating careful handling of division by zero (parallel lines), integer overflow, and sign conventions for floored division.

\section{Overview}\label{sec:lichao}

This section presents the Li-Chao tree, the primary contribution of this technical report.

\subsection{Algorithmic Approach}

The LICT offers a fundamentally different approach based on implicit envelope maintenance through interval subdivision. Rather than tracking the convex hull geometry explicitly, the structure maintains the best line at each interval midpoint, recursively partitioning the query range.

Each node in the tree represents an interval $[\text{left}, \text{right}]$ and stores one line. During insertion, a line is \emph{routed} through the tree following a single path from root to leaf. At each node on this path, the new line is compared with the currently stored line. The line that achieves the lower value at the midpoint $\text{mid} = (\text{left}+\text{right})/2$ is \emph{stored} at that node; the suboptimal line continues downward to be routed through the appropriate child subtree.

\textbf{Key invariant (local optimality).} A line stored at a node achieves the minimum value among all lines routed through that node at the midpoint of the node's interval. Formally, for node with interval $[\text{left}, \text{right}]$ and midpoint $\text{mid} = (\text{left}+\text{right})/2$, the stored line minimizes $kx + b$ at $x = \text{mid}$ among all lines routed to that node.

Note that this is \emph{local} optimality only. Lines routed down other branches may achieve lower values at $m$, so the stored line is not necessarily globally optimal at that coordinate.

\textbf{Why this maintains the lower envelope.} Consider two lines $A$ and $B$ compared at a node's midpoint:
\begin{itemize}
    \item If $A$ achieves a lower value than $B$ at $\text{mid}$, but $B$ yields a lower value at one endpoint, then $B$ can only outperform $A$ on the side of $\text{mid}$ containing that endpoint (since two lines intersect at most once).
    \item Therefore, $B$ is routed to exactly one child---the side where it might achieve a lower value.
\end{itemize}

At query time, we traverse the path to $x_0$ and take the minimum over all stored lines on that path. For any line $L$ and query point $x_0$:
\begin{enumerate}
    \item Line $L$ is routed down exactly one root-to-leaf path.
    \item The query for $x_0$ traverses exactly this path (the unique path whose intervals all contain $x_0$).
    \item Line $L$ is stored at some node on this path if and only if $L$ achieved the minimum value at that node's midpoint.
    \item Therefore, all lines that could potentially be optimal at $x_0$ are evaluated.
\end{enumerate}
The minimum among stored lines on the path equals the global lower envelope at $x_0$.

Insertion proceeds as follows: if the new line yields a lower value at the midpoint, the lines are swapped and the suboptimal line continues down. The key geometric insight is that two distinct lines intersect at most once. Therefore, if a line yields a higher value at the midpoint, it can yield a lower value than the stored line on at most one side of the midpoint, never both. This property guarantees that the suboptimal line need only be propagated down a single child path.

The appropriate child is determined by where the relative ordering changes. Let $f_\text{new}(x) = k_\text{new} x + b_\text{new}$ denote the new line and $f_\text{stored}(x) = k_\text{stored} x + b_\text{stored}$ denote the line currently stored at the node. Define the comparison indicators:
\begin{align*}
    L &= \mathbb{I}[f_\text{new}(\text{left}) < f_\text{stored}(\text{left})] \\
    M &= \mathbb{I}[f_\text{new}(\text{mid}) < f_\text{stored}(\text{mid})]
\end{align*}
where $\mathbb{I}[\cdot]$ is the indicator function. The child selection rule is:
\begin{equation*}
    \text{child} =
    \begin{cases}
        \text{left} & \text{if } L \neq M \\
        \text{right} & \text{if } L = M
    \end{cases}
\end{equation*}
This follows from the single-intersection property: if the ordering changes between $\text{left}$ and $\text{mid}$, the intersection point lies in $[\text{left}, \text{mid}]$; otherwise, it lies in $[\text{mid}, \text{right}]$.

\textbf{Complexity Proof Sketch.} The LICT is a binary tree over the coordinate range $[\text{left}, \text{right}]$ with depth $O(\log C)$ where $C = \frac{\text{right} - \text{left}}{\epsilon}$ and $\epsilon$ is the precision level (for integer coordinates, $\epsilon = 1$). During insertion, the new line follows exactly one root-to-leaf path. At each node along this path, we perform $O(1)$ work: evaluating both lines at the endpoints and midpoint, and optionally swapping them. Since the path length is $O(\log C)$ and each level requires constant time, insertion takes $O(\log C)$ time. Queries similarly traverse one root-to-leaf path, evaluating the stored line at each node for $O(\log C)$ total time.

\textbf{Querying.} To query the minimum value at a coordinate $x_0$, we traverse the tree from root to leaf, following the path corresponding to the interval containing $x_0$. At each node, we evaluate the stored line at $x_0$ and keep track of the minimum value seen. The traversal proceeds to the left child if $x_0$ is in the left half of the current interval, or to the right child otherwise. When reaching a leaf (or a null child), we return the minimum value accumulated along the path. This traversal visits at most one node per tree level, yielding $O(\log C)$ query time.

\begin{itemize}
    \item \textbf{Time Complexity:} $O(\log C)$ per operation, where $C = \frac{\text{coordinate range}}{\text{precision level}}$ (typically $C \approx 10^9$ for 32-bit integer coordinates).
    \item \textbf{Space Complexity:} At most $O(n \log C)$ nodes in the worst case when all lines follow disjoint paths through the tree. In practice, heavy node sharing occurs as lines with similar slopes traverse common paths, typically resulting in significantly lower memory usage.
    \item \textbf{Key Characteristics:} No intersection calculations required; all decisions based on direct line value comparisons at integer coordinates.
\end{itemize}

\textbf{Deletion.} Unlike the Dynamic CHT, which can support deletion of arbitrary lines in $O(\log n)$ amortized time, the standard LICT does not support efficient deletion. Removing a line would require traversing all nodes where that line might be stored and recomputing optimal lines from descendants, which requires $\Omega(n)$ time in the worst case. For applications requiring deletion, an alternative approach is reconstructing the tree periodically.

The LICT's complexity depends on the coordinate range rather than the number of lines. This provides consistent performance regardless of hull size, though it cannot exploit cases where the hull remains small relative to the number of insertions.

\subsection{Comparison with Dynamic CHT}

Table~\ref{tab:comparison} summarizes the key differences between the Dynamic CHT and LICT.

\begin{table}[h]
\centering
\caption{Comparison of Dynamic CHT and Li-Chao tree}
\label{tab:comparison}
\begin{tabular}{@{}lcc@{}}
\toprule
\textbf{Characteristic} & \textbf{Dynamic CHT} & \textbf{LICT} \\
\midrule
Time Complexity & $O(\log n)$ amortized & $O(\log C)$ \\
Space Complexity & $O(n)$ & $O(n \log C)$ worst case \\
Intersection Calculations & Required & None \\
Numerical Precision & Care required & Straightforward \\
Line Segment Extension & Complex & Natural \\
Persistence Support & Difficult & Straightforward \\
Implementation Complexity & Higher & Lower \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Key Trade-offs}

The choice between these approaches involves several trade-offs:

\textbf{Performance versus simplicity.} The Dynamic CHT achieves faster query and insertion times, particularly when the hull remains small relative to the number of insertions. The LICT provides implementation simplicity and reduced code complexity at the cost of some performance.

\textbf{Geometric versus combinatorial.} The Dynamic CHT relies on geometric calculations (intersection points) that require careful numerical handling. The LICT uses only combinatorial operations (line evaluations at integer coordinates), avoiding precision concerns.

\textbf{Static versus extensible.} The Dynamic CHT's explicit hull structure makes extensions such as persistence and line segments difficult. The LICT's recursive tree structure naturally accommodates these extensions.

\subsection{Trade-off Summary}

Our empirical evaluation (detailed in Section~\ref{sec:benchmarks}) demonstrates that the Dynamic CHT achieves approximately 1.45 to 2.00 times faster execution across problem scales ranging from $10^5$ to $10^7$ operations. However, the LICT's implementation requires approximately half the code of the Dynamic CHT (45 lines vs.~88 lines in our implementations) and eliminates an entire class of potential bugs related to intersection calculations. For applications where implementation time, correctness guarantees, or extensibility are paramount, the LICT offers a compelling alternative despite its higher computational cost.

\section{Implementation}\label{sec:implementation}

We present streamlined implementations emphasizing clarity and correctness.

\subsection{Dynamic CHT}

Listing~\ref{lst:dcht} presents our Dynamic CHT implementation using \texttt{std::multiset}.

\begin{lstlisting}[language=C++, caption={Dynamic CHT Implementation}, label={lst:dcht}]
// Type alias for 64-bit integers. Use 'long long' in standard C++.
typedef long long llint;

struct Line {
    mutable llint k, m, p;
    bool operator<(const Line& o) const { return k < o.k; }
    bool operator<(llint x) const { return p < x; }
};

struct LineContainer : multiset<Line, less<>> {
    static const llint inf = LLONG_MAX;
    
    llint div(llint a, llint b) {
        return a / b - ((a ^ b) < 0 && a % b);
    }
    
    bool isect(iterator x, iterator y) {
        if (y == end()) return x->p = inf, 0;
        if (x->k == y->k)
            x->p = x->m > y->m ? inf : -inf;
        else
            x->p = div(y->m - x->m, x->k - y->k);
        return x->p >= y->p;
    }
    
    void add(llint k, llint m) {
        auto z = insert({k, m, 0}), y = z++, x = y;
        while (isect(y, z)) z = erase(z);
        if (x != begin() && isect(--x, y))
            isect(x, y = erase(y));
        while ((y = x) != begin() && (--x)->p >= y->p)
            isect(x, erase(y));
    }
    
    // Query returns 0 if the container is empty. Caller should check
    // empty() first if a different default value is required.
    llint query(llint x) {
        if (empty()) return 0;
        auto l = *lower_bound(x);
        return l.k * x + l.m;
    }
};
\end{lstlisting}

\subsection{Standard LICT}

Listing~\ref{lst:lichao} presents our Standard LICT implementation.

\begin{lstlisting}[language=C++, caption={Standard LICT Implementation}, label={lst:lichao}]
// Type alias for 64-bit integers. Use 'long long' in standard C++.
typedef long long llint;

// INF must be larger than any possible query result. With k, x, m bounded
// such that |k*x + m| < 4e18, this value ensures min() operations work correctly.
// For 64-bit signed integers, LLONG_MAX = 9.22e18, so 4e18 is safe.
const llint INF = 4e18;

struct Line {
    llint k, m;
    // Evaluates the line at coordinate x. 
    // WARNING: k * x + m can overflow 64-bit integers. Use __int128 for
    // intermediate calculation if |k|, |x|, |m| may exceed ~3e9, or ensure
    // input ranges are bounded appropriately.
    llint eval(llint x) const { return k * x + m; }
};

struct Node {
    Line line;
    Node *left = nullptr, *right = nullptr;
    Node(Line l) : line(l) {}
};

class LiChaoTree {
    Node* root = nullptr;
    llint min_x, max_x;

    void insert(Node* &node, Line new_line, llint l, llint r) {
        if (!node) {
            node = new Node(new_line);
            return;
        }
        llint mid = l + (r - l) / 2;
        bool lef = new_line.eval(l) < node->line.eval(l);
        bool midf = new_line.eval(mid) < node->line.eval(mid);

        if (midf) swap(node->line, new_line);
        if (l == r) return;
        if (lef != midf)
            insert(node->left, new_line, l, mid);
        else
            insert(node->right, new_line, mid + 1, r);
    }

    llint query(Node* node, llint x, llint l, llint r) {
        if (!node) return INF;
        llint mid = l + (r - l) / 2;
        llint val = node->line.eval(x);
        if (l == r) return val;
        if (x <= mid)
            return min(val, query(node->left, x, l, mid));
        else
            return min(val, query(node->right, x, mid + 1, r));
    }

public:
    LiChaoTree(llint min_val = -1e9, llint max_val = 1e9)
        : min_x(min_val), max_x(max_val) {}

    void add_line(llint k, llint m) {
        insert(root, {k, m}, min_x, max_x);
    }

    // Query returns INF if the tree is empty (no lines inserted).
    // Caller should check for this condition if empty tree is possible.
    llint query(llint x) {
        return query(root, x, min_x, max_x);
    }
};
\end{lstlisting}

\subsection{Empty Container Behavior}

The implementations differ in their handling of empty container queries. The Dynamic CHT returns 0 when empty, while the LICT returns $\texttt{INF}$ (a sentinel value larger than any valid query result). This difference reflects typical usage patterns: the Dynamic CHT often appears in competitive programming contexts where 0 is a natural default (e.g., maximizing DP transitions), while the LICT's INF return makes explicit that no lines have been inserted. Callers should check \texttt{empty()} or handle the sentinel value appropriately based on application requirements.

\section{Benchmarks}\label{sec:benchmarks}

To validate the theoretical complexity analysis and characterize practical performance differences between the two approaches, we conducted systematic empirical evaluation across varying problem scales and input distributions.

\subsection{Experimental Setup}

All benchmarks were conducted with the following configuration:
\begin{itemize}
    \item \textbf{Compiler:} g++ 11.4.0 with \texttt{-O3 -std=c++17}
    \item \textbf{Platform:} Linux x86\_64
    \item \textbf{Test sizes:} $10^5$, $10^6$, and $10^7$ operations
    \item \textbf{Coordinate range:} $C = 10^9$ (assuming integer precision $\epsilon = 1$), with $x, k, m \in [-10^9, 10^9]$
    \item \textbf{Random seed:} 42 (fixed for reproducibility)
    \item \textbf{Measurement protocol:} Each test was run 10 times; reported times are the median. Variance was low ($<5\%$ coefficient of variation across runs). Benchmarks were run on an isolated system with no other user processes to minimize timing noise.
    \item \textbf{Distributions:} We write $X \sim U(a, b)$ to denote that random variable $X$ is drawn from a continuous uniform distribution over the interval $[a, b]$.
    \begin{itemize}
        \item \textbf{Random:} Slopes $k \sim U(-10^9, 10^9)$, intercepts $m \sim U(-10^9, 10^9)$. Expected hull size: $\Theta(\sqrt{n})$.
        \item \textbf{All on Hull:} Lines $y = i \cdot x - i^2$ for $i \in [1, n]$. All $n$ lines contribute to the hull.
    \end{itemize}
\end{itemize}

\subsection{Results}

Table~\ref{tab:results} presents the performance comparison.

\begin{table}[h]
\centering
\caption{Performance Comparison (Time in milliseconds)}
\label{tab:results}
\begin{tabular}{@{}ccccc@{}}
\toprule
\textbf{N} & \textbf{Distribution} & \textbf{LICT} & \textbf{Dynamic CHT} & \textbf{Ratio} \\
\midrule
$10^5$ & Random & 10 ms & 5 ms & $2.00\times$ \\
$10^5$ & All on Hull & 6 ms & 4 ms & $1.50\times$ \\
\midrule
$10^6$ & Random & 77 ms & 52 ms & $1.48\times$ \\
$10^6$ & All on Hull & 67 ms & 41 ms & $1.63\times$ \\
\midrule
$10^7$ & Random & 789 ms & 545 ms & $1.45\times$ \\
$10^7$ & All on Hull & 687 ms & 426 ms & $1.61\times$ \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Analysis}

The Dynamic CHT demonstrates consistently faster execution across all test cases, with performance advantage ranging from 1.45 to 2.00 times. The gap is most pronounced at smaller problem sizes and narrows as $N$ increases.

The relationship between hull size and performance exhibits scale-dependent behavior. At smaller scales, the Dynamic CHT benefits more significantly from skipping irrelevant lines. At larger scales, cache effects become dominant, and the pattern becomes less pronounced.

Both implementations exhibit logarithmic scaling consistent with their theoretical complexity guarantees.

\section{Discussion}\label{sec:discussion}

\subsection{Advantages of the Li-Chao tree}

Despite higher computational cost, the LICT offers significant advantages for practical applications:

\textbf{1. Implementation simplicity.} The LICT eliminates complex geometric calculations, reducing implementation time and probability of errors. This is particularly important in competitive programming and rapid prototyping contexts.

\textbf{2. Numerical stability.} The LICT performs only integer addition and multiplication for line evaluation. The Dynamic CHT requires division for intersection calculations, necessitating careful handling of edge cases including parallel lines and overflow conditions.

\textbf{3. Floating-point queries.} For non-integer (floating-point) query coordinates, the LICT requires increased tree depth to achieve the required precision. Specifically, to distinguish coordinates within $\epsilon$ of each other over range $C$, the tree depth becomes $O(\log(C/\epsilon))$. With coordinate range $10^9$ and double precision ($\epsilon \approx 10^{-9}$), the tree depth increases from approximately 30 to 60. In such cases, the Dynamic CHT's $O(\log n)$ complexity (independent of coordinate precision) becomes relatively more attractive. Applications requiring both floating-point coordinates and the LICT's implementation advantages may use coordinate transformation to convert queries to integers (e.g., by scaling and rounding to the smallest representable unit).

\textbf{4. Extensibility.} The LICT's structure facilitates extensions that are difficult with the Dynamic CHT:
\begin{itemize}
    \item \textbf{Line segments:} Lines valid only on subranges $[l', r']$ integrate naturally. During insertion, when the current node interval $[l, r]$ lies entirely outside $[l', r']$, we skip that subtree. When $[l, r]$ lies entirely inside, we proceed normally. Otherwise, we recurse into both children. This limits the line's influence to its valid range without modifying the core algorithm.
    \item \textbf{Persistence:} Path copying for versioned access requires minimal modification.
    \item \textbf{Higher dimensions:} Generalization to multi-dimensional query spaces follows naturally from the recursive structure.
\end{itemize}

\section{Conclusion}\label{sec:conclusion}

This technical report has presented a comprehensive analysis of the Li-Chao tree as an alternative to the Dynamic Convex Hull Trick for online line container queries. Our empirical evaluation confirms that the Dynamic CHT achieves superior raw performance, while the LICT provides advantages in implementation simplicity, numerical stability, and extensibility.

The Li-Chao tree represents a distinct point in the design space, trading constant factor performance for reduced implementation complexity and enhanced flexibility. For applications requiring persistence, line segment support, or rapid implementation, the LICT offers compelling advantages. For performance-critical applications with bounded hull size, the Dynamic CHT remains preferable.

Since its introduction in 2012, the Li-Chao tree has found widespread adoption in competitive programming and algorithmic education. Its continued relevance demonstrates that optimal asymptotic complexity is not the sole criterion for practical data structure selection; implementation clarity and extensibility play equally important roles in determining utility.

\begin{thebibliography}{5}

\bibitem{overmars1981}
Overmars, M.H. and van Leeuwen, J.
\newblock Maintenance of configurations in the plane.
\newblock \emph{Journal of Computer and System Sciences}, 23(2):166--204, 1981.

\bibitem{zjoi2012}
Li Chao.
\newblock Lecture at Zhejiang Provincial Olympiad in Informatics (ZJOI 2012).
\newblock China, 2012.

\bibitem{cp-algorithms}
CP-Algorithms.
\newblock Li-Chao tree.
\newblock \url{https://cp-algorithms.com/geometry/li_chao_tree.html}, 2024.
\newblock Accessed: 2025-02-06.

\bibitem{codeforces}
I\_LOVE\_TIGER.
\newblock Li-Chao tree Tutorial.
\newblock \url{https://codeforces.com/blog/entry/51275}, 2017.
\newblock Accessed: 2025-02-06.

\bibitem{kactl}
KTH Algorithm Library (KACTL).
\newblock LineContainer.
\newblock \url{https://github.com/kth-competitive-programming/kactl}, 2024.
\newblock Accessed: 2025-02-06.

\end{thebibliography}

\end{document}
